{"README.md":"\n> Open this page at [https://humberto-jezus.github.io/gjgfnm/](https://humberto-jezus.github.io/gjgfnm/)\n\n## Use as Extension\n\nThis repository can be added as an **extension** in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **New Project**\n* click on **Extensions** under the gearwheel menu\n* search for **https://github.com/humberto-jezus/gjgfnm** and import\n\n## Edit this project\n\nTo edit this repository in MakeCode.\n\n* open [https://makecode.microbit.org/](https://makecode.microbit.org/)\n* click on **Import** then click on **Import URL**\n* paste **https://github.com/humberto-jezus/gjgfnm** and click import\n\n#### Metadata (used for search, rendering)\n\n* for PXT/microbit\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\n","custom.ts":"\n/**\n* Use this file to define custom functions and blocks.\n* Read more at https://makecode.microbit.org/blocks/custom\n*/\n\nenum MyEnum {\n    //% block=\"one\"\n    One,\n    //% block=\"two\"\n    Two\n}\n\n/**\n * Custom blocks\n */\n//% weight=100 color=#0fbc11 icon=\"ïƒƒ\"\nnamespace custom {\n    /**\n     * TODO: describe your function here\n     * @param n describe parameter here, eg: 5\n     * @param s describe parameter here, eg: \"Hello\"\n     * @param e describe parameter here\n     */\n    //% block\n    export function foo(n: number, s: string, e: MyEnum): void {\n        // Add code here\n    }\n\n    /**\n     * TODO: describe your function here\n     * @param value describe value here, eg: 5\n     */\n    //% block\n    export function fib(value: number): number {\n        return value <= 1 ? value : fib(value -1) + fib(value - 2);\n    }\n}\n","extebsao.ts":"// Add your code here\n\nenum PIN {\n    P0 = 3,\n    P1 = 2,\n    P2 = 1,\n    P8 = 18,\n    //P9 = 10,\n    P12 = 20,\n    P13 = 23,\n    P14 = 22,\n    P15 = 21,\n};\n\nenum Motors {\n    //% block=\"left\"\n    M1 = 1,\n    //% block=\"right\"\n    M2 = 2,\n    //% block=\"ALL\"\n    ALL = 3\n}\n\nenum Motors1 {\n    //% block=\"left\"\n    M1 = 1,\n    //% block=\"right\"\n    M2 = 2,\n}\n\nenum Dir {\n    //% block=\"rotate forward\"\n    CW = 1,\n    //% block=\"backward\"\n    CCW = 2\n}\n\nenum Servos {\n    //% block=\"S1\"\n    S1 = 1,\n    //% block=\"S2\"\n    S2 = 2,\n    //% block=\"S3\"\n    S3 = 3\n}\n\nenum RGBLight {\n    //%block=\"RGB_L\"\n    RGBL = 1,\n    //%block=\"RGB_R\"\n    RGBR = 2,\n    //%block=\"ALL\"\n    RGBA = 3\n}\n\nenum Patrol {\n    //% block=\"L1\"\n    L1 = 1,\n    //%block=\"L2\"\n    L2 = 2,\n    //%block=\"L3\"\n    L3 = 5,\n    //%block=\"R1\"\n    R1 = 3,\n    //%block=\"R2\"\n    R2 = 4,\n    //%block=\"R3\"\n    R3 = 6\n}\n\nenum Sonicunit {\n    //% block=\"cm\"\n    Centimeters\n}\n\nenum PID {\n    //%block=\"OFF\"\n    OFF = 0,\n    //%block=\"ON\"\n    ON = 1\n}\n\nenum Color {\n    //%block=\"Red\"\n    RED = 1,\n    //%block=\"Green\"\n    GREEN = 2,\n    //%block=\"Blue\"\n    BLUE = 4,\n    //%block=\"Yellow\"\n    YELLOW = 3,\n    //%block=\"Violet\"\n    PINK = 5,\n    //%block=\"Cyan\"\n    CYAN = 6,\n    //%block=\"White\"\n    WHITH = 7,\n    //%block=\"OFF\"\n    OFF = 8\n\n}\n\n//% weight=100  color=#00A654   block=\"Maqueen Plus\" icon=\"\\uf067\"\nnamespace DFRobotMaqueenPlus {\n    let irstate:number;\n    let state:number;\n    export class Packeta {\n        public mye: string;\n        public myparam: number;\n    }\n   \n    /**\n     *  Init I2C until success\n     */\n    //% weight=100\n    //%block=\"initialize via I2C until success\"\n    export function I2CInit():void{\n        let Version_v = 0;\n        pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);\n        Version_v = pins.i2cReadNumber(0x10, NumberFormat.Int8LE);\n        while (Version_v==0){\n            basic.showLeds(`\n                # . . . #\n                . # . # .\n                . . # . .\n                . # . # .\n                # . . . #\n                `, 10)\n            basic.pause(500)\n            basic.clearScreen()\n            pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);\n            Version_v = pins.i2cReadNumber(0x10, NumberFormat.Int8LE);\n        }\n        basic.showLeds(`\n                . . . . .\n                . . . . #\n                . . . # .\n                # . # . .\n                . # . . .\n                `, 10)\n        basic.pause(500)\n        basic.clearScreen()\n    }\n\n    /**\n     * PID control module\n     */\n    //% weight=90\n    //%block=\"PID switch|%pid\"\n    export function PID(pid: PID): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = 0x0A;\n        buf[1] = pid;\n        pins.i2cWriteBuffer(0x10, buf);\n    }\n    /**\n     * Motor control module\n     */\n    //% weight=80\n    //% block=\"motor|%index|direction|%direction|speed|%speed \"\n    //% speed.min=0 speed.max=255\n    export function mototRun(index: Motors, direction: Dir, speed: number): void {\n        let _speed:number;\n        if(speed >= 240) _speed=240;\n        else _speed=speed;\n        if (index == 1) {\n            let buf = pins.createBuffer(3)\n            buf[0] = 0x00;\n            buf[1] = direction;\n            buf[2] = _speed;\n            pins.i2cWriteBuffer(0x10, buf)\n\n        } if (index == 2) {\n            let buf = pins.createBuffer(3)\n            buf[0] = 0x02;\n            buf[1] = direction;\n            buf[2] = _speed;\n            pins.i2cWriteBuffer(0x10, buf)\n        }\n        if (index == 3) {\n            let buf = pins.createBuffer(5)\n            buf[0] = 0x00;\n            buf[1] = direction;\n            buf[2] = _speed;\n            buf[3] = direction;\n            buf[4] = _speed;\n            pins.i2cWriteBuffer(0x10, buf)\n        }\n    }\n    /**\n     * Motor stop module\n     */\n    //% weight=75\n    //% block=\"Motor|%index stop\"\n    export function mototStop(index: Motors): void {\n\n        if (index == 1) {\n            let buf = pins.createBuffer(3)\n            buf[0] = 0x00;\n            buf[1] = 0;\n            buf[2] = 0;\n            pins.i2cWriteBuffer(0x10, buf)\n\n        } if (index == 2) {\n            let buf = pins.createBuffer(3)\n            buf[0] = 0x02;\n            buf[1] = 0;\n            buf[2] = 0;\n            pins.i2cWriteBuffer(0x10, buf)\n        }\n        if (index == 3) {\n            let buf = pins.createBuffer(5)\n            buf[0] = 0x00;\n            buf[1] = 0;\n            buf[2] = 0;\n            buf[3] = 0;\n            buf[4] = 0;\n            pins.i2cWriteBuffer(0x10, buf)\n        }\n    }\n\n\n    /**\n     * Compensate speed difference between two motors\n     */\n    // //% weight=7\n    // //% block=\"motor compensation|%motor speed|%speed\"\n    // //% speed.min=0 speed.max=255\n    // export function mostotCompensation(motor: Motors1, speed: number): void {\n    //     let buf = pins.createBuffer(2)\n    //     if (motor == 1) {\n    //         buf[0] = 0x08;\n    //         buf[1] = speed;\n    //         pins.i2cWriteBuffer(0x10, buf)\n    //     } else if (motor == 2) {\n    //         buf[0] = 0x09;\n    //         buf[1] = speed;\n    //         pins.i2cWriteBuffer(0x10, buf)\n    //     }\n    // }\n    \n    /**\n     * Read motor speed\n     */\n    //% weight=65\n    //%block=\"read motor|%index speed\"\n    export function readSpeed(index: Motors1): number {\n        let _speed:number,ret = -1;\n        pins.i2cWriteNumber(0x10, 0, NumberFormat.Int8LE)\n        let speed_x = pins.i2cReadBuffer(0x10, 4)\n        if (index == 1) {\n            if((Math.round(speed_x[1])<20) && (Math.round(speed_x[1]) != 0)){\n               ret = Math.round(speed_x[1]) + 255;\n            }else{\n                ret = Math.round(speed_x[1]);\n            }\n        } else if (index == 2) {\n            if((Math.round(speed_x[3])<20) && (Math.round(speed_x[3]) != 0)){\n                ret = Math.round(speed_x[3]) + 255;\n            }else{\n                ret = Math.round(speed_x[3]);\n            }\n        }\n        return ret;\n    }\n    /**\n     * Read motor direction(stop:0,forward:1,back:2)\n     */\n    //% weight=61\n    //%block=\"read motor|%index direction(stop:0,forward:1,back:2)\"\n    export function readDirection(index: Motors1): number {\n        pins.i2cWriteNumber(0x10, 0, NumberFormat.Int8LE)\n        let dir_x = pins.i2cReadBuffer(0x10, 4)\n        if (index == 1) {\n            return dir_x[0]\n\n        } else if (index == 2) {\n            return dir_x[2]\n        }\n        return -1\n    }\n\n    /**\n     * Servo control module\n     */\n    //% weight=40\n    //% block=\"servo|%index|angle|%angle\"\n    //% angle.min=0  angle.max=180\n    export function servoRun(index: Servos, angle: number): void {\n        let buf = pins.createBuffer(2)\n        switch (index) {\n            case 1:\n                buf[0] = 0x14;\n                buf[1] = angle;\n                pins.i2cWriteBuffer(0x10, buf);\n                break;\n            case 2:\n                buf[0] = 0x15;\n                buf[1] = angle;\n                pins.i2cWriteBuffer(0x10, buf);\n                break;\n            default:\n                buf[0] = 0x16;\n                buf[1] = angle;\n                pins.i2cWriteBuffer(0x10, buf);\n                break;\n        }\n    }\n\n    /**\n     * Control the color of RGB LED \n     */\n    //% weight=50\n    //% block=\"set |%rgbshow color|%color\"\n    export function setRGBLight(rgbshow: RGBLight, color: Color): void {\n\n        if (rgbshow == 1) {\n            let buf = pins.createBuffer(2)\n            buf[0] = 0x0B;\n            buf[1] = color;\n            pins.i2cWriteBuffer(0x10, buf);\n        } if (rgbshow == 2) {\n            let buf = pins.createBuffer(2)\n            buf[0] = 0x0C;\n            buf[1] = color;\n            pins.i2cWriteBuffer(0x10, buf);\n        } if (rgbshow == 3) {\n            let buf = pins.createBuffer(3)\n            buf[0] = 0x0B;\n            buf[1] = color;\n            buf[2] = color;\n            pins.i2cWriteBuffer(0x10, buf);\n        }\n\n    }\n\n    /**\n     * Read line-tracking sensor status\n     */\n    //% weight=56\n    //%block=\"read line-tracking sensor|%patrol\"\n    export function readPatrol(patrol: Patrol): number {\n        pins.i2cWriteNumber(0x10, 0x1D, NumberFormat.Int8LE);\n        let patrol_y = pins.i2cReadBuffer(0x10, 1);\n        let mark: number ;\n        switch (patrol) {\n            case 1: mark = (patrol_y[0] & 0x04) == 0x04 ? 1 : 0; break;\n            case 2: mark = (patrol_y[0] & 0x02) == 0x02 ? 1 : 0; break;\n            case 3: mark = (patrol_y[0] & 0x08) == 0x08 ? 1 : 0; break;\n            case 4: mark = (patrol_y[0] & 0x10) == 0x10 ? 1 : 0; break;\n            case 5: mark = (patrol_y[0] & 0x01) == 0x01 ? 1 : 0; break;\n            case 6: mark = (patrol_y[0] & 0x20) == 0x20 ? 1 : 0; break;\n        }\n        \n        return mark\n    }\n\n    /**\n     * Read grayscale value of line-tracking sensor\n     */\n    //% weight=55\n    //% block=\"read line-tracking sensor|%patrol grayscale \"\n    export function readPatrolVoltage(patrol: Patrol): number {\n        pins.i2cWriteNumber(0x10, 0x1E, NumberFormat.Int8LE);\n        let patrolv_y = pins.i2cReadBuffer(0x10, 12);\n        let patrol_AD: number;\n        switch (patrol) {\n            case 1:\n                patrol_AD = patrolv_y[5] | patrolv_y[4] << 8;\n                break;\n            case 2:\n                patrol_AD = patrolv_y[3] | patrolv_y[2] << 8;\n                break;\n            case 3:\n                patrol_AD = patrolv_y[7] | patrolv_y[6] << 8;\n                break;\n            case 4:\n                patrol_AD = patrolv_y[9] | patrolv_y[8] << 8;\n                break;\n            case 5:\n                patrol_AD = patrolv_y[1] | patrolv_y[0] << 8;\n                break;\n            default:\n                patrol_AD = patrolv_y[11] | patrolv_y[10] << 8;\n                break;\n\n        }\n        return patrol_AD;\n    }\n    /**\n     * Get product information\n     */\n    //% weight=5\n    //%block=\"get product information\"\n    export function readVersion(): string {\n        pins.i2cWriteNumber(0x10, 0x32, NumberFormat.Int8LE);\n        let Version_v = pins.i2cReadNumber(0x10, NumberFormat.Int8LE);\n        pins.i2cWriteNumber(0x10, 0x33, NumberFormat.Int8LE);\n        let Version_y = pins.i2cReadBuffer(0x10, Version_v);\n        let Version_x = Version_y.toString();\n        return Version_x;\n    }\n    /**\n     * Read the distance value the ultrasound returns \n     */\n    let state1 = 0;\n    //% weight=20\n    //%block=\"read ultrasonic sensor TRIG %T ECHO %E Company:CM\"\n    export function ultraSonic(T: PIN, E: PIN): number {\n        \n        let data;\n        let i = 0;\n        data = readUlt(T, E);\n        if(state1  == 1 && data != 0){\n            state1 =0;\n        }\n        if(data != 0){\n        }else{\n            if(state1 == 0){\n                do{\n                    data = readUlt(T, E);\n                    i++;\n                    if(i > 3){\n                        state1 =1;\n                        data =500;\n                        break;\n                        }\n                }while(data == 0)\n            }\n        }\n        if(data == 0)\n            data = 500\n        return data;\n    }\n\n    function readUlt(T:number, E:number):number{\n        let maxCmDistance = 500;\n        let _T;\n        let _E;\n        switch (T) {\n            case PIN.P0: _T = DigitalPin.P0; break;\n            case PIN.P1: _T = DigitalPin.P1; break;\n            case PIN.P2: _T = DigitalPin.P2; break;\n            case PIN.P8: _T = DigitalPin.P8; break;\n            case PIN.P12: _T = DigitalPin.P12; break;\n            // case PIN.P10: _T = DigitalPin.P10; break;\n            case PIN.P13: _T = DigitalPin.P13; break;\n            case PIN.P14: _T = DigitalPin.P14; break;\n            case PIN.P15: _T = DigitalPin.P15; break;\n            default: _T = DigitalPin.P0; break;\n        }\n\n        switch (E) {\n            case PIN.P0: _E = DigitalPin.P0; break;\n            case PIN.P1: _E = DigitalPin.P1; break;\n            case PIN.P2: _E = DigitalPin.P2; break;\n            case PIN.P8: _E = DigitalPin.P8; break;\n            //case PIN.P9: _E = DigitalPin.P9; break;\n            case PIN.P12: _E = DigitalPin.P12; break;\n            case PIN.P13: _E = DigitalPin.P13; break;\n            case PIN.P14: _E = DigitalPin.P14; break;\n            case PIN.P15: _E = DigitalPin.P15; break;\n            default: _E = DigitalPin.P0; break;\n        }\n\n        let ultraSonic_d;\n        // pins.digitalWritePin(_T, 1);\n        // basic.pause(1)\n        pins.digitalWritePin(_T, 0);\n        if (pins.digitalReadPin(_E) == 0) {\n            pins.digitalWritePin(_T, 0);\n            pins.digitalWritePin(_T, 1);\n            basic.pause(20);\n            pins.digitalWritePin(_T, 0);\n            ultraSonic_d = pins.pulseIn(_E, PulseValue.High, maxCmDistance * 58);\n        } else {\n            pins.digitalWritePin(_T, 1);\n            pins.digitalWritePin(_T, 0);\n            basic.pause(20);\n            pins.digitalWritePin(_T, 0);\n            ultraSonic_d = pins.pulseIn(_E, PulseValue.Low, maxCmDistance * 58);\n        }\n        let ultraSonic_x = ultraSonic_d / 59;\n        // if (ultraSonic_x <= 0 || ultraSonic_x > 300) {\n        //     return 0;\n        // }\n        return Math.round(ultraSonic_x);\n    }\n    \n    /**\n     * get the revolutions of wheel\n     */\n    //% weight=60\n    //%block=\"get the revolutions of wheel %motor\"\n    export function readeDistance(motor:Motors1):string {\n        let distance:number;\n        pins.i2cWriteNumber(0x10, 4, NumberFormat.Int8LE)\n        let speed_x = pins.i2cReadBuffer(0x10, 4)\n        switch(motor){\n            case 1:distance = ((speed_x[0]<<8|speed_x[1])*10)/900;break;\n            default:distance = ((speed_x[2]<<8|speed_x[3])*10)/900;break;\n        }\n        let index=distance.toString().indexOf(\".\");\n        let x:string=distance.toString().substr(0,index+3)\n        return x;\n        basic.pause(30)\n    }\n    /**\n     * clear the revolutions of wheel \n     */\n    //% weight=60\n    //%block=\"clear the revolutions of wheel %motor\" \n    export function clearDistance(motor:Motors):void{\n        \n        switch(motor){\n            case 1: \n                let buf1 = pins.createBuffer(2);\n                buf1[0] = 0x04;\n                buf1[1] = 0;\n                pins.i2cWriteBuffer(0x10, buf1);\n                break;\n            case 2:\n                let buf2 = pins.createBuffer(2);\n                buf2[0] = 0x06;\n                buf2[1] = 0;\n                pins.i2cWriteBuffer(0x10, buf2);\n                break;\n            default:\n                let buf3 = pins.createBuffer(4);\n                buf3[0] = 0x04;\n                buf3[1] = 0;\n                buf3[2] = 0;\n                buf3[3] = 0;\n                pins.i2cWriteBuffer(0x10, buf3);\n        }\n    }\n}\n","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"></xml>","main.ts":"\n","pxt.json":"{\n    \"name\": \"gjgfnm\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\",\n        \"cutebot\": \"github:elecfreaks/pxt-cutebot#v6.1.13\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\",\n        \"custom.ts\",\n        \"extebsao.ts\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"targetVersions\": {\n        \"target\": \"6.0.28\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// tests go here; this will not be compiled when this package is used as an extension.\n"}